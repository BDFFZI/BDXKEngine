# 反射

## 提供功能

- 运行时访问和使用类型信息
    - 构造函数
    - 字段
- 提供数据传输接口

## 实现目的
实现对象的克隆和持久化保存以及实现不依赖成员访问权限的遍历和修改对象数据的功能，便于后期添加编辑器功能。

## 设计思路

### 字段传输器

能传输一个对象里的所有字段信息，包括类型，名称，地址等。这将用于后续的反射和序列化功能中，甚至编辑器也可以接用其实现，因为可以通过它实现遍历字段的操作。

#### 继承传输

遍历哪些字段由对象自己决定，并且遍历函数应设置为虚函数，以便实现继承数据的传递。

#### 自定义传输

- 传输哪些字段
  在遍历函数中提供一个传输器对象，传输器对象提供传输函数，对象自行调用它们来选择性提供字段信息。
- 如何传输字段  
  考虑自定义类型的存在，具体的传输方式也应该可以由对象自己决定。对象可以注册自定义函数并与类型绑定，当然传输器也应该默认注册一些常用类型，以减少工作量。

#### 优化方案

这种传输方式虽然扩展性强，但存在性能问题，首先注册信息需要频繁用到堆内存，寻址查询也需要不少时间。

- 采用内联形式的传输函数，这是性能最佳的方式，但这样可传输的类型就固定了，且会造成耦合性。
- 采用单例模式，将信息注册只放在首次创建时。
- 使用更快的键值类型进行查询。

### 反射

封装性要求我们不要把对象的私有功能直接公开出来，但有些值我们可能需要进行调整，特别是在做一些编辑器扩展时，所以我们需要一种不通过常规的对象访问方式也能读写值的办法。

#### 读写方式

从C++语法层面，有一种访问私有变量的方法，即友元，但友元会导致产生耦合性，所以不采用。另一个更适合的方式是直接从内存层面处理。

#### 信息获取

我们需要遍历类的所有字段，这部分由类自己提供，而我们则负责提供字段传输器，然后通过字段传输器获取到类中的所有字段并解析其信息。  
其中我们需要记录字段相对对象的地址偏移，这样后面我们可以直接修改此处内存来实现数据读写。